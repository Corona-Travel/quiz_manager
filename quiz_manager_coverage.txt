============================= test session starts ==============================
platform linux -- Python 3.9.9, pytest-5.4.3, py-1.11.0, pluggy-0.13.1
rootdir: /corona_travel
plugins: anyio-3.4.0
collected 1 item

test_quiz_manager.py F                                                   [100%]

=================================== FAILURES ===================================
_______________________________ test_get_quizzes _______________________________

remote_host = 'quizzes', remote_port = 80

    async def connect_tcp(
        remote_host: IPAddressType, remote_port: int, *, local_host: Optional[IPAddressType] = None,
        tls: bool = False, ssl_context: Optional[ssl.SSLContext] = None,
        tls_standard_compatible: bool = True, tls_hostname: Optional[str] = None,
        happy_eyeballs_delay: float = 0.25
    ) -> Union[SocketStream, TLSStream]:
        """
        Connect to a host using the TCP protocol.
    
        This function implements the stateless version of the Happy Eyeballs algorithm (RFC 6555).
        If ``address`` is a host name that resolves to multiple IP addresses, each one is tried until
        one connection attempt succeeds. If the first attempt does not connected within 250
        milliseconds, a second attempt is started using the next address in the list, and so on.
        On IPv6 enabled systems, an IPv6 address (if available) is tried first.
    
        When the connection has been established, a TLS handshake will be done if either
        ``ssl_context`` or ``tls_hostname`` is not ``None``, or if ``tls`` is ``True``.
    
        :param remote_host: the IP address or host name to connect to
        :param remote_port: port on the target host to connect to
        :param local_host: the interface address or name to bind the socket to before connecting
        :param tls: ``True`` to do a TLS handshake with the connected stream and return a
            :class:`~anyio.streams.tls.TLSStream` instead
        :param ssl_context: the SSL context object to use (if omitted, a default context is created)
        :param tls_standard_compatible: If ``True``, performs the TLS shutdown handshake before closing
            the stream and requires that the server does this as well. Otherwise,
            :exc:`~ssl.SSLEOFError` may be raised during reads from the stream.
            Some protocols, such as HTTP, require this option to be ``False``.
            See :meth:`~ssl.SSLContext.wrap_socket` for details.
        :param tls_hostname: host name to check the server certificate against (defaults to the value
            of ``remote_host``)
        :param happy_eyeballs_delay: delay (in seconds) before starting the next connection attempt
        :return: a socket stream object if no TLS handshake was done, otherwise a TLS stream
        :raises OSError: if the connection attempt fails
    
        """
        # Placed here due to https://github.com/python/mypy/issues/7057
        connected_stream: Optional[SocketStream] = None
    
        async def try_connect(remote_host: str, event: Event) -> None:
            nonlocal connected_stream
            try:
                stream = await asynclib.connect_tcp(remote_host, remote_port, local_address)
            except OSError as exc:
                oserrors.append(exc)
                return
            else:
                if connected_stream is None:
                    connected_stream = stream
                    tg.cancel_scope.cancel()
                else:
                    await stream.aclose()
            finally:
                event.set()
    
        asynclib = get_asynclib()
        local_address: Optional[IPSockAddrType] = None
        family = socket.AF_UNSPEC
        if local_host:
            gai_res = await getaddrinfo(str(local_host), None)
            family, *_, local_address = gai_res[0]
    
        target_host = str(remote_host)
        try:
>           addr_obj = ip_address(remote_host)

/usr/local/lib/python3.9/site-packages/anyio/_core/_sockets.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = 'quizzes'

    def ip_address(address):
        """Take an IP string/int and return an object of the correct type.
    
        Args:
            address: A string or integer, the IP address.  Either IPv4 or
              IPv6 addresses may be supplied; integers less than 2**32 will
              be considered to be IPv4 by default.
    
        Returns:
            An IPv4Address or IPv6Address object.
    
        Raises:
            ValueError: if the *address* passed isn't either a v4 or a v6
              address
    
        """
        try:
            return IPv4Address(address)
        except (AddressValueError, NetmaskValueError):
            pass
    
        try:
            return IPv6Address(address)
        except (AddressValueError, NetmaskValueError):
            pass
    
>       raise ValueError('%r does not appear to be an IPv4 or IPv6 address' %
                         address)
E       ValueError: 'quizzes' does not appear to be an IPv4 or IPv6 address

/usr/local/lib/python3.9/ipaddress.py:53: ValueError

During handling of the above exception, another exception occurred:

self = <httpcore.backends.asyncio.AsyncIOBackend object at 0x7f78a0c8a9d0>
host = 'quizzes', port = 80, timeout = 5.0, local_address = None

    async def connect_tcp(
        self, host: str, port: int, timeout: float = None, local_address: str = None
    ) -> AsyncNetworkStream:
        exc_map = {
            TimeoutError: ConnectTimeout,
            OSError: ConnectError,
            anyio.BrokenResourceError: ConnectError,
        }
        with map_exceptions(exc_map):
            with anyio.fail_after(timeout):
>               stream: anyio.abc.ByteStream = await anyio.connect_tcp(
                    remote_host=host,
                    remote_port=port,
                    local_host=local_address,
                )

/usr/local/lib/python3.9/site-packages/httpcore/backends/asyncio.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

remote_host = 'quizzes', remote_port = 80

    async def connect_tcp(
        remote_host: IPAddressType, remote_port: int, *, local_host: Optional[IPAddressType] = None,
        tls: bool = False, ssl_context: Optional[ssl.SSLContext] = None,
        tls_standard_compatible: bool = True, tls_hostname: Optional[str] = None,
        happy_eyeballs_delay: float = 0.25
    ) -> Union[SocketStream, TLSStream]:
        """
        Connect to a host using the TCP protocol.
    
        This function implements the stateless version of the Happy Eyeballs algorithm (RFC 6555).
        If ``address`` is a host name that resolves to multiple IP addresses, each one is tried until
        one connection attempt succeeds. If the first attempt does not connected within 250
        milliseconds, a second attempt is started using the next address in the list, and so on.
        On IPv6 enabled systems, an IPv6 address (if available) is tried first.
    
        When the connection has been established, a TLS handshake will be done if either
        ``ssl_context`` or ``tls_hostname`` is not ``None``, or if ``tls`` is ``True``.
    
        :param remote_host: the IP address or host name to connect to
        :param remote_port: port on the target host to connect to
        :param local_host: the interface address or name to bind the socket to before connecting
        :param tls: ``True`` to do a TLS handshake with the connected stream and return a
            :class:`~anyio.streams.tls.TLSStream` instead
        :param ssl_context: the SSL context object to use (if omitted, a default context is created)
        :param tls_standard_compatible: If ``True``, performs the TLS shutdown handshake before closing
            the stream and requires that the server does this as well. Otherwise,
            :exc:`~ssl.SSLEOFError` may be raised during reads from the stream.
            Some protocols, such as HTTP, require this option to be ``False``.
            See :meth:`~ssl.SSLContext.wrap_socket` for details.
        :param tls_hostname: host name to check the server certificate against (defaults to the value
            of ``remote_host``)
        :param happy_eyeballs_delay: delay (in seconds) before starting the next connection attempt
        :return: a socket stream object if no TLS handshake was done, otherwise a TLS stream
        :raises OSError: if the connection attempt fails
    
        """
        # Placed here due to https://github.com/python/mypy/issues/7057
        connected_stream: Optional[SocketStream] = None
    
        async def try_connect(remote_host: str, event: Event) -> None:
            nonlocal connected_stream
            try:
                stream = await asynclib.connect_tcp(remote_host, remote_port, local_address)
            except OSError as exc:
                oserrors.append(exc)
                return
            else:
                if connected_stream is None:
                    connected_stream = stream
                    tg.cancel_scope.cancel()
                else:
                    await stream.aclose()
            finally:
                event.set()
    
        asynclib = get_asynclib()
        local_address: Optional[IPSockAddrType] = None
        family = socket.AF_UNSPEC
        if local_host:
            gai_res = await getaddrinfo(str(local_host), None)
            family, *_, local_address = gai_res[0]
    
        target_host = str(remote_host)
        try:
            addr_obj = ip_address(remote_host)
        except ValueError:
            # getaddrinfo() will raise an exception if name resolution fails
>           gai_res = await getaddrinfo(target_host, remote_port, family=family,
                                        type=socket.SOCK_STREAM)
E           asyncio.exceptions.CancelledError

/usr/local/lib/python3.9/site-packages/anyio/_core/_sockets.py:152: CancelledError

During handling of the above exception, another exception occurred:

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>, <class 'anyio.BrokenResourceError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: Dict[Type[Exception], Type[Exception]]) -> Iterator[None]:
        try:
>           yield

/usr/local/lib/python3.9/site-packages/httpcore/_exceptions.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.backends.asyncio.AsyncIOBackend object at 0x7f78a0c8a9d0>
host = 'quizzes', port = 80, timeout = 5.0, local_address = None

    async def connect_tcp(
        self, host: str, port: int, timeout: float = None, local_address: str = None
    ) -> AsyncNetworkStream:
        exc_map = {
            TimeoutError: ConnectTimeout,
            OSError: ConnectError,
            anyio.BrokenResourceError: ConnectError,
        }
        with map_exceptions(exc_map):
            with anyio.fail_after(timeout):
>               stream: anyio.abc.ByteStream = await anyio.connect_tcp(
                    remote_host=host,
                    remote_port=port,
                    local_host=local_address,
                )

/usr/local/lib/python3.9/site-packages/httpcore/backends/asyncio.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio._core._tasks.FailAfterContextManager object at 0x7f78a0c8a910>
exc_type = <class 'asyncio.exceptions.CancelledError'>
exc_val = CancelledError(), exc_tb = <traceback object at 0x7f78a0cde880>

    def __exit__(self, exc_type: Optional[Type[BaseException]],
                 exc_val: Optional[BaseException],
                 exc_tb: Optional[TracebackType]) -> Optional[bool]:
        retval = self._cancel_scope.__exit__(exc_type, exc_val, exc_tb)
        if self._cancel_scope.cancel_called:
>           raise TimeoutError
E           TimeoutError

/usr/local/lib/python3.9/site-packages/anyio/_core/_tasks.py:103: TimeoutError

During handling of the above exception, another exception occurred:

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        try:
>           yield

/usr/local/lib/python3.9/site-packages/httpx/_transports/default.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncHTTPTransport object at 0x7f78a0c8dd60>
request = <Request('GET', 'http://quizzes/quizzes')>

    async def handle_async_request(
        self,
        request: Request,
    ) -> Response:
        assert isinstance(request.stream, AsyncByteStream)
    
        req = httpcore.Request(
            method=request.method,
            url=httpcore.URL(
                scheme=request.url.raw_scheme,
                host=request.url.raw_host,
                port=request.url.port,
                target=request.url.raw_path,
            ),
            headers=request.headers.raw,
            content=request.stream,
            extensions=request.extensions,
        )
        with map_httpcore_exceptions():
>           resp = await self._pool.handle_async_request(req)

/usr/local/lib/python3.9/site-packages/httpx/_transports/default.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.AsyncConnectionPool object at 0x7f78a0c8dd90>
request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        """
        Send an HTTP request, and return an HTTP response.
    
        This is the core implementation that is called into by `.request()` or `.stream()`.
        """
        scheme = request.url.scheme.decode()
        if scheme == "":
            raise UnsupportedProtocol(
                "Request URL is missing an 'http://' or 'https://' protocol."
            )
        if scheme not in ("http", "https"):
            raise UnsupportedProtocol(
                f"Request URL has an unsupported protocol '{scheme}://'."
            )
    
        status = RequestStatus(request)
    
        async with self._pool_lock:
            self._requests.append(status)
            await self._close_expired_connections()
            await self._attempt_to_acquire_connection(status)
    
        while True:
            timeouts = request.extensions.get("timeout", {})
            timeout = timeouts.get("pool", None)
            connection = await status.wait_for_connection(timeout=timeout)
            try:
                response = await connection.handle_async_request(request)
            except ConnectionNotAvailable:
                # The ConnectionNotAvailable exception is a special case, that
                # indicates we need to retry the request on a new connection.
                #
                # The most common case where this can occur is when multiple
                # requests are queued waiting for a single connection, which
                # might end up as an HTTP/2 connection, but which actually ends
                # up as HTTP/1.1.
                async with self._pool_lock:
                    # Maintain our position in the request queue, but reset the
                    # status so that the request becomes queued again.
                    status.unset_connection()
                    await self._attempt_to_acquire_connection(status)
            except Exception as exc:
                await self.response_closed(status)
>               raise exc

/usr/local/lib/python3.9/site-packages/httpcore/_async/connection_pool.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.AsyncConnectionPool object at 0x7f78a0c8dd90>
request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        """
        Send an HTTP request, and return an HTTP response.
    
        This is the core implementation that is called into by `.request()` or `.stream()`.
        """
        scheme = request.url.scheme.decode()
        if scheme == "":
            raise UnsupportedProtocol(
                "Request URL is missing an 'http://' or 'https://' protocol."
            )
        if scheme not in ("http", "https"):
            raise UnsupportedProtocol(
                f"Request URL has an unsupported protocol '{scheme}://'."
            )
    
        status = RequestStatus(request)
    
        async with self._pool_lock:
            self._requests.append(status)
            await self._close_expired_connections()
            await self._attempt_to_acquire_connection(status)
    
        while True:
            timeouts = request.extensions.get("timeout", {})
            timeout = timeouts.get("pool", None)
            connection = await status.wait_for_connection(timeout=timeout)
            try:
>               response = await connection.handle_async_request(request)

/usr/local/lib/python3.9/site-packages/httpcore/_async/connection_pool.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTPConnection [CONNECTION FAILED]>, request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        if not self.can_handle_request(request.url.origin):
            raise RuntimeError(
                f"Attempted to send request to {request.url.origin} on connection to {self._origin}"
            )
    
        async with self._request_lock:
            if self._connection is None:
                try:
                    stream = await self._connect(request)
    
                    ssl_object = stream.get_extra_info("ssl_object")
                    http2_negotiated = (
                        ssl_object is not None
                        and ssl_object.selected_alpn_protocol() == "h2"
                    )
                    if http2_negotiated or (self._http2 and not self._http1):
                        from .http2 import AsyncHTTP2Connection
    
                        self._connection = AsyncHTTP2Connection(
                            origin=self._origin,
                            stream=stream,
                            keepalive_expiry=self._keepalive_expiry,
                        )
                    else:
                        self._connection = AsyncHTTP11Connection(
                            origin=self._origin,
                            stream=stream,
                            keepalive_expiry=self._keepalive_expiry,
                        )
                except Exception as exc:
                    self._connect_failed = True
>                   raise exc

/usr/local/lib/python3.9/site-packages/httpcore/_async/connection.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTPConnection [CONNECTION FAILED]>, request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        if not self.can_handle_request(request.url.origin):
            raise RuntimeError(
                f"Attempted to send request to {request.url.origin} on connection to {self._origin}"
            )
    
        async with self._request_lock:
            if self._connection is None:
                try:
>                   stream = await self._connect(request)

/usr/local/lib/python3.9/site-packages/httpcore/_async/connection.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTPConnection [CONNECTION FAILED]>, request = <Request [b'GET']>

    async def _connect(self, request: Request) -> AsyncNetworkStream:
        timeouts = request.extensions.get("timeout", {})
        timeout = timeouts.get("connect", None)
    
        retries_left = self._retries
        delays = exponential_backoff(factor=RETRIES_BACKOFF_FACTOR)
    
        while True:
            try:
                if self._uds is None:
                    kwargs = {
                        "host": self._origin.host.decode("ascii"),
                        "port": self._origin.port,
                        "local_address": self._local_address,
                        "timeout": timeout,
                    }
                    async with Trace(
                        "connection.connect_tcp", request, kwargs
                    ) as trace:
>                       stream = await self._network_backend.connect_tcp(**kwargs)

/usr/local/lib/python3.9/site-packages/httpcore/_async/connection.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.backends.auto.AutoBackend object at 0x7f78a0c8dca0>
host = 'quizzes', port = 80, timeout = 5.0, local_address = None

    async def connect_tcp(
        self, host: str, port: int, timeout: float = None, local_address: str = None
    ) -> AsyncNetworkStream:
        await self._init_backend()
>       return await self._backend.connect_tcp(
            host, port, timeout=timeout, local_address=local_address
        )

/usr/local/lib/python3.9/site-packages/httpcore/backends/auto.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.backends.asyncio.AsyncIOBackend object at 0x7f78a0c8a9d0>
host = 'quizzes', port = 80, timeout = 5.0, local_address = None

    async def connect_tcp(
        self, host: str, port: int, timeout: float = None, local_address: str = None
    ) -> AsyncNetworkStream:
        exc_map = {
            TimeoutError: ConnectTimeout,
            OSError: ConnectError,
            anyio.BrokenResourceError: ConnectError,
        }
        with map_exceptions(exc_map):
            with anyio.fail_after(timeout):
>               stream: anyio.abc.ByteStream = await anyio.connect_tcp(
                    remote_host=host,
                    remote_port=port,
                    local_host=local_address,
                )

/usr/local/lib/python3.9/site-packages/httpcore/backends/asyncio.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7f78a0c8ab20>
typ = <class 'TimeoutError'>, value = TimeoutError()
traceback = <traceback object at 0x7f78a0cde080>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(typ, value, traceback)

/usr/local/lib/python3.9/contextlib.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>, <class 'anyio.BrokenResourceError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: Dict[Type[Exception], Type[Exception]]) -> Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc)
E                   httpcore.ConnectTimeout

/usr/local/lib/python3.9/site-packages/httpcore/_exceptions.py:12: ConnectTimeout

The above exception was the direct cause of the following exception:

    def test_get_quizzes():
>       response = client.get("/quiz_manager/all/quizzes")

test_quiz_manager.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.9/site-packages/requests/sessions.py:555: in get
    return self.request('GET', url, **kwargs)
/usr/local/lib/python3.9/site-packages/starlette/testclient.py:468: in request
    return super().request(
/usr/local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
/usr/local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
/usr/local/lib/python3.9/site-packages/starlette/testclient.py:266: in send
    raise exc
/usr/local/lib/python3.9/site-packages/starlette/testclient.py:263: in send
    portal.call(self.app, scope, receive, send)
/usr/local/lib/python3.9/site-packages/anyio/from_thread.py:240: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/usr/local/lib/python3.9/concurrent/futures/_base.py:445: in result
    return self.__get_result()
/usr/local/lib/python3.9/concurrent/futures/_base.py:390: in __get_result
    raise self._exception
/usr/local/lib/python3.9/site-packages/anyio/from_thread.py:187: in _call_func
    retval = await retval
/usr/local/lib/python3.9/site-packages/fastapi/applications.py:208: in __call__
    await super().__call__(scope, receive, send)
/usr/local/lib/python3.9/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py:181: in __call__
    raise exc
/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py:159: in __call__
    await self.app(scope, receive, _send)
/usr/local/lib/python3.9/site-packages/starlette/middleware/cors.py:84: in __call__
    await self.app(scope, receive, send)
/usr/local/lib/python3.9/site-packages/starlette/exceptions.py:82: in __call__
    raise exc
/usr/local/lib/python3.9/site-packages/starlette/exceptions.py:71: in __call__
    await self.app(scope, receive, sender)
/usr/local/lib/python3.9/site-packages/starlette/routing.py:656: in __call__
    await route.handle(scope, receive, send)
/usr/local/lib/python3.9/site-packages/starlette/routing.py:259: in handle
    await self.app(scope, receive, send)
/usr/local/lib/python3.9/site-packages/starlette/routing.py:61: in app
    response = await func(request)
/usr/local/lib/python3.9/site-packages/fastapi/routing.py:226: in app
    raw_response = await run_endpoint_function(
/usr/local/lib/python3.9/site-packages/fastapi/routing.py:159: in run_endpoint_function
    return await dependant.call(**values)
quiz_manager/app.py:54: in get_all_quizzes
    res = await client.get(f"{settings.quizzes_url}quizzes")
/usr/local/lib/python3.9/site-packages/httpx/_client.py:1736: in get
    return await self.request(
/usr/local/lib/python3.9/site-packages/httpx/_client.py:1513: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
/usr/local/lib/python3.9/site-packages/httpx/_client.py:1600: in send
    response = await self._send_handling_auth(
/usr/local/lib/python3.9/site-packages/httpx/_client.py:1628: in _send_handling_auth
    response = await self._send_handling_redirects(
/usr/local/lib/python3.9/site-packages/httpx/_client.py:1665: in _send_handling_redirects
    response = await self._send_single_request(request)
/usr/local/lib/python3.9/site-packages/httpx/_client.py:1702: in _send_single_request
    response = await transport.handle_async_request(request)
/usr/local/lib/python3.9/site-packages/httpx/_transports/default.py:291: in handle_async_request
    resp = await self._pool.handle_async_request(req)
/usr/local/lib/python3.9/contextlib.py:137: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE-786
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: nocover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectTimeout

/usr/local/lib/python3.9/site-packages/httpx/_transports/default.py:77: ConnectTimeout
=========================== short test summary info ============================
FAILED test_quiz_manager.py::test_get_quizzes - httpx.ConnectTimeout
============================== 1 failed in 11.93s ==============================
